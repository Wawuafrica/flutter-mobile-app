# Fastfile
# This file contains the fastlane configuration

# Disable analytics
opt_out_usage

# Define the iOS platform
platform :ios do
  desc "Build and upload to TestFlight - Force Fresh Build"
  lane :beta do
    setup_ci

    # Force clean everything at the start
    UI.message("üßπ Starting complete clean build process...")
    
    # Clean all Xcode derived data and build artifacts
    clear_derived_data
    
    # Setup keychain for CI with unique name to avoid conflicts
    keychain_name = "signing_keychain_#{Time.now.to_i}"
    
    create_keychain(
      name: keychain_name,
      password: ENV['MATCH_KEYCHAIN_PASSWORD'],
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )
    UI.message("üîë Keychain '#{keychain_name}' created and unlocked")

    # Load App Store Connect API key
    api_key = app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_ISSUER_ID'],
      key_filepath: './AuthKey.p8'
    )

    # Force refresh certificates and provisioning profiles
    UI.message("üîê Fetching fresh certificates and provisioning profiles...")
    match(
      type: "appstore",
      keychain_name: keychain_name,
      keychain_password: ENV['MATCH_KEYCHAIN_PASSWORD'],
      readonly: true, # Allow updates to handle new devices or expired profiles
      app_identifier: "com.wawuafrica.wawu",
      git_url: ENV['MATCH_GIT_URL'],
      git_basic_authorization: Base64.strict_encode64("#{ENV['MATCH_GIT_TOKEN']}:x-oauth-basic"),
      storage_mode: "git",
      api_key: api_key,
      force_for_new_devices: true,
      clone_branch_directly: true,
      skip_confirmation: true,
      verbose: true
    )
    UI.message("‚úÖ Match completed - certificates and profiles refreshed")

    # Get the provisioning profile name
    profile_name = Actions.lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING]["com.wawuafrica.wawu"]
    UI.message("üìã Using provisioning profile: #{profile_name}")

    # Update project team settings
    update_project_team(
      path: "Runner.xcodeproj",
      teamid: ENV['APPLE_TEAM_ID']
    )
    UI.message("üë• Updated project team settings")

    # Generate unique build number using timestamp + run number
    timestamp = Time.now.strftime("%Y%m%d%H%M")
    run_number = ENV['GITHUB_RUN_NUMBER'] || rand(1000..9999).to_s
    unique_build_number = "#{timestamp}#{run_number}"
    
    # Set the unique build number
    increment_build_number(
      build_number: unique_build_number,
      xcodeproj: "Runner.xcodeproj"
    )
    UI.message("üî¢ Build number set to: #{unique_build_number}")

    # Force clean Flutter build
    UI.message("üîÑ Starting clean Flutter build...")
    Dir.chdir("..") do
      # Clean everything Flutter-related
      sh("flutter", "clean")
      sh("rm", "-rf", "build")
      sh("rm", "-rf", ".dart_tool")
      
      # Fresh pub get
      sh("flutter", "pub", "get")
      
      # Build with no codesign
      sh("flutter", "build", "ios", "--release", "--no-codesign", "--verbose")
    end
    UI.message("‚úÖ Flutter build completed")

    # Clean iOS build artifacts before signing
    UI.message("üßπ Cleaning iOS build artifacts...")
    sh("rm", "-rf", "../build/ios")
    sh("rm", "-rf", "./build")
    
    # Update code signing settings manually
    require 'xcodeproj'
    project = Xcodeproj::Project.open("../Runner.xcodeproj")

    project.targets.each do |target|
      if target.name == "Runner"
        target.build_configurations.each do |config|
          if config.name == "Release"
            config.build_settings["CODE_SIGN_STYLE"] = "Manual"
            config.build_settings["PROVISIONING_PROFILE_SPECIFIER"] = profile_name
            config.build_settings["DEVELOPMENT_TEAM"] = ENV['APPLE_TEAM_ID']
            config.build_settings["CODE_SIGN_IDENTITY[sdk=iphoneos*]"] = "iPhone Distribution"
            # Force clean build settings
            config.build_settings.delete("PROVISIONING_PROFILE")
            config.build_settings.delete("CODE_SIGN_IDENTITY")
            config.build_settings["ONLY_ACTIVE_ARCH"] = "NO"
          end
        end
      end
    end

    project.save
    UI.message("‚öôÔ∏è Updated code signing settings")

    # Build and sign with forced clean
    UI.message("üèóÔ∏è Building and signing iOS app...")
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "com.wawuafrica.wawu" => profile_name
        },
        signingStyle: "manual",
        teamID: ENV['APPLE_TEAM_ID'],
        signingCertificate: "iPhone Distribution",
        uploadBitcode: false,
        uploadSymbols: true,
        compileBitcode: false,
        stripSwiftSymbols: true,
        thinning: "<thin-for-all-variants>"
      },
      clean: true, # Force clean build
      verbose: true,
      xcargs: "-allowProvisioningUpdates",
      output_directory: "./build/ios/ipa/",
      silent: false,
      # Force rebuild by cleaning derived data
      derived_data_path: "/tmp/DerivedData-#{Time.now.to_i}"
    )
    UI.message("‚úÖ iOS app built and signed successfully")

    # Upload to TestFlight with processing wait
    UI.message("üì§ Uploading to TestFlight...")
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: false, # Wait for processing to ensure build is ready
      skip_submission: false,
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Build #{unique_build_number} - Fresh deployment from GitHub Actions at #{Time.now.strftime('%Y-%m-%d %H:%M:%S UTC')}",
      ipa: "./build/ios/ipa/Runner.ipa" # Explicitly specify IPA path
    )
    UI.message("üéâ Successfully uploaded to TestFlight!")

    # Clean up keychain
    delete_keychain(name: keychain_name)
    UI.message("üßπ Keychain cleaned up")
  end

  # Error handling with proper cleanup
  error do |lane, exception|
    UI.error("‚ùå Error occurred in lane #{lane}: #{exception.message}")
    
    # Clean up any keychains that might have been created
    begin
      # Try to find and delete any signing keychains
      keychains = `security list-keychains`.split("\n").map(&:strip).map { |k| k.gsub(/^"/, '').gsub(/"$/, '') }
      keychains.each do |keychain|
        if keychain.include?("signing_keychain")
          delete_keychain(name: File.basename(keychain, "-db"))
          UI.message("üßπ Cleaned up keychain: #{keychain}")
        end
      end
    rescue => cleanup_error
      UI.message("‚ö†Ô∏è Keychain cleanup warning: #{cleanup_error.message}")
    end
    
    # Clean up build artifacts
    sh("rm", "-rf", "./build") rescue nil
    sh("rm", "-rf", "../build") rescue nil
    
    raise exception
  end
end